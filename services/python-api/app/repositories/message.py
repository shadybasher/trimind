"""Message repository with specialized query methods.

This module provides message-specific database operations.
"""

from typing import List, Optional
from sqlmodel import select
from sqlmodel.ext.asyncio.session import AsyncSession
from app.db_models import Message, RoleEnum, ProviderEnum
from app.repositories.base import BaseRepository


class MessageRepository(BaseRepository[Message]):
    """Repository for Message model with specialized queries."""

    def __init__(self, session: AsyncSession):
        """Initialize with Message model."""
        super().__init__(Message, session)

    async def get_by_session(self, session_id: str, limit: int = 100) -> List[Message]:
        """
        Get all messages for a session, ordered by creation time.

        Args:
            session_id: Session ID to filter by
            limit: Maximum number of messages to return

        Returns:
            List of messages in chronological order
        """
        result = await self.session.execute(
            select(Message)
            .where(Message.sessionId == session_id)
            .order_by(Message.createdAt)
            .limit(limit)
        )
        return list(result.scalars().all())

    async def get_latest_by_session(self, session_id: str, count: int = 10) -> List[Message]:
        """
        Get latest N messages for a session.

        Args:
            session_id: Session ID to filter by
            count: Number of latest messages to return

        Returns:
            List of latest messages in chronological order
        """
        result = await self.session.execute(
            select(Message)
            .where(Message.sessionId == session_id)
            .order_by(Message.createdAt.desc())
            .limit(count)
        )
        # Reverse to get chronological order
        return list(reversed(list(result.scalars().all())))

    async def create_with_provider(
        self,
        session_id: str,
        user_id: str,
        role: str,
        content: str,
        provider: Optional[str] = None,
        model: Optional[str] = None,
    ) -> Message:
        """
        Create a message with LLM provider metadata.

        Args:
            session_id: Session ID
            user_id: User ID
            role: Message role (user/assistant/system)
            content: Message content
            provider: Optional LLM provider (openai/anthropic/google)
            model: Optional model name

        Returns:
            Created message instance
        """
        message = Message(
            sessionId=session_id,
            userId=user_id,
            role=role,
            content=content,
            provider=provider,
            model=model,
        )
        return await self.create(message)

    async def get_user_messages(self, session_id: str) -> List[Message]:
        """
        Get only user messages for a session.

        Args:
            session_id: Session ID to filter by

        Returns:
            List of user messages
        """
        result = await self.session.execute(
            select(Message)
            .where(Message.sessionId == session_id, Message.role == RoleEnum.USER.value)
            .order_by(Message.createdAt)
        )
        return list(result.scalars().all())

    async def get_assistant_messages(self, session_id: str) -> List[Message]:
        """
        Get only assistant messages for a session.

        Args:
            session_id: Session ID to filter by

        Returns:
            List of assistant messages
        """
        result = await self.session.execute(
            select(Message)
            .where(Message.sessionId == session_id, Message.role == RoleEnum.ASSISTANT.value)
            .order_by(Message.createdAt)
        )
        return list(result.scalars().all())

    async def count_by_session(self, session_id: str) -> int:
        """
        Count messages in a session.

        Args:
            session_id: Session ID to filter by

        Returns:
            Total message count
        """
        result = await self.session.execute(
            select(Message).where(Message.sessionId == session_id)
        )
        return len(list(result.scalars().all()))

    async def get_by_provider(self, provider: str, limit: int = 100) -> List[Message]:
        """
        Get messages generated by a specific LLM provider.

        Args:
            provider: Provider name (openai/anthropic/google)
            limit: Maximum number of messages

        Returns:
            List of messages from that provider
        """
        result = await self.session.execute(
            select(Message)
            .where(Message.provider == provider)
            .order_by(Message.createdAt.desc())
            .limit(limit)
        )
        return list(result.scalars().all())
